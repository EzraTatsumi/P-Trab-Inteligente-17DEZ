import { useEffect, useState, useMemo, useRef } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { ArrowLeft, Package, Pencil, Trash2, XCircle, Check, ChevronDown, ClipboardList, Sparkles } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { OmSelector } from "@/components/OmSelector";
import { OMData } from "@/lib/omUtils";
import { sanitizeError } from "@/lib/errorUtils";
import { useFormNavigation } from "@/hooks/useFormNavigation";
import { updatePTrabStatusIfAberto } from "@/lib/ptrabUtils";
import { formatCurrency, formatNumber } from "@/lib/formatUtils";
import { DiretrizClasseII } from "@/types/diretrizesClasseII";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Command, CommandGroup, CommandItem } from "@/components/ui/command";
import { Checkbox } from "@/components/ui/checkbox";
import { TablesInsert } from "@/integrations/supabase/types";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { defaultClasseIIConfig } from "@/data/classeIIData";
import { cn } from "@/lib/utils";
import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog"; // Importar Dialog components

type Categoria = 'Equipamento Individual' | 'Proteção Balística' | 'Material de Estacionamento';

const CATEGORIAS: Categoria[] = [
  "Equipamento Individual",
  "Proteção Balística",
  "Material de Estacionamento",
];

// Opções fixas de fase de atividade
const FASES_PADRAO = ["Reconhecimento", "Mobilização", "Execução", "Reversão"];

interface ItemClasseII {
  item: string;
  quantidade: number;
  valor_mnt_dia: number;
  categoria: Categoria; // Adicionado categoria ao item para detalhamento
  memoria_customizada?: string | null; // NOVO CAMPO
}

interface FormDataClasseII {
  selectedOmId?: string;
  organizacao: string;
  ug: string;
  dias_operacao: number;
  itens: ItemClasseII[];
  fase_atividade?: string;
}

interface ClasseIIRegistro {
  id: string;
  organizacao: string;
  ug: string;
  dias_operacao: number;
  categoria: string; // Agora será 'CONSOLIDADO' ou a categoria do único item
  itens_equipamentos: ItemClasseII[]; // Tipo corrigido
  valor_total: number;
  detalhamento: string;
  detalhamento_customizado?: string | null;
  fase_atividade?: string;
}

export default function ClasseIIForm() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const ptrabId = searchParams.get("ptrabId");
  
  const [registros, setRegistros] = useState<ClasseIIRegistro[]>([]);
  const [loading, setLoading] = useState(false);
  const [diretrizes, setDiretrizes] = useState<DiretrizClasseII[]>([]);
  const [selectedTab, setSelectedTab] = useState<Categoria>(CATEGORIAS[0]);
  
  const [editingId, setEditingId] = useState<string | null>(null);
  
  const [form, setForm] = useState<FormDataClasseII>({
    selectedOmId: undefined,
    organizacao: "",
    ug: "",
    dias_operacao: 0,
    itens: [],
  });
  
  const [itemTemp, setItemTemp] = useState<ItemClasseII>({
    item: "",
    quantidade: 0,
    valor_mnt_dia: 0,
    categoria: CATEGORIAS[0], // Inicializa com a primeira categoria
  });
  const [editingItemIndex, setEditingItemIndex] = useState<number | null>(null);
  
  const [fasesAtividade, setFasesAtividade] = useState<string[]>(["Execução"]);
  const [customFaseAtividade, setCustomFaseAtividade] = useState<string>("");
  const [isPopoverOpen, setIsPopoverOpen] = useState(false);
  
  // Estados para edição de memória individual
  const [showMemoriaDialog, setShowMemoriaDialog] = useState(false);
  const [currentMemoriaItem, setCurrentMemoriaItem] = useState<{
    registroId: string;
    itemIndex: number;
    itemNome: string;
    memoria: string;
    memoriaOriginal: string;
  } | null>(null);

  const { handleEnterToNextField } = useFormNavigation();
  const formRef = useRef<HTMLDivElement>(null);
  const itemSelectRef = useRef<HTMLButtonElement>(null);

  useEffect(() => {
    if (!ptrabId) {
      toast.error("ID do P Trab não encontrado");
      navigate("/ptrab");
      return;
    }
    loadDiretrizes();
    fetchRegistros();
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, [ptrabId]);

  const loadDiretrizes = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const currentYear = new Date().getFullYear();
      let anoReferencia = currentYear;

      const { data: diretrizCusteio } = await supabase
        .from("diretrizes_custeio")
        .select("ano_referencia")
        .eq("user_id", user.id)
        .order("ano_referencia", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (diretrizCusteio) {
        anoReferencia = diretrizCusteio.ano_referencia;
      } else {
        toast.warning(`Diretriz de Custeio não encontrada para o ano ${currentYear}. Por favor, configure em 'Configurações > Diretriz de Custeio'.`);
      }

      const { data: classeIIData, error } = await supabase
        .from("diretrizes_classe_ii")
        .select("*")
        .eq("user_id", user.id)
        .eq("ano_referencia", anoReferencia)
        .eq("ativo", true);

      if (error) throw error;

      if (classeIIData && classeIIData.length > 0) {
        setDiretrizes((classeIIData || []) as DiretrizClasseII[]);
      } else {
        setDiretrizes(defaultClasseIIConfig as DiretrizClasseII[]);
        toast.warning(`Itens de Classe II não configurados para o ano ${anoReferencia}. Usando valores padrão.`);
      }
      
    } catch (error) {
      console.error("Erro ao carregar diretrizes:", error);
      setDiretrizes(defaultClasseIIConfig as DiretrizClasseII[]);
      toast.error("Erro ao carregar diretrizes. Usando valores padrão.");
    }
  };

  const fetchRegistros = async () => {
    if (!ptrabId) return;
    
    const { data, error } = await supabase
      .from("classe_ii_registros")
      .select("*, itens_equipamentos, detalhamento_customizado")
      .eq("p_trab_id", ptrabId)
      .order("created_at", { ascending: false });

    if (error) {
      toast.error("Erro ao carregar registros");
      console.error(error);
      return;
    }

    const uniqueRecordsMap = new Map<string, ClasseIIRegistro>();
    (data || []).forEach(r => {
        const key = `${r.organizacao}-${r.ug}`;
        uniqueRecordsMap.set(key, r as ClasseIIRegistro);
    });

    setRegistros(Array.from(uniqueRecordsMap.values()));
  };

  // Função para formatar as fases de forma natural no texto
  const formatFasesParaTexto = (faseCSV: string | null | undefined): string => {
    if (!faseCSV) return 'operação';
    
    const fases = faseCSV.split(';').map(f => f.trim()).filter(f => f);
    
    if (fases.length === 0) return 'operação';
    if (fases.length === 1) return fases[0];
    if (fases.length === 2) return `${fases[0]} e ${fases[1]}`;
    
    const ultimaFase = fases[fases.length - 1];
    const demaisFases = fases.slice(0, -1).join(', ');
    return `${demaisFases} e ${ultimaFase}`;
  };

  // Função de Detalhamento CONSOLIDADA (mantida para salvar no DB)
  const generateDetalhamento = (itens: ItemClasseII[], diasOperacao: number, organizacao: string, faseAtividade: string): string => {
    const faseFormatada = formatFasesParaTexto(faseAtividade);
    const totalItens = itens.reduce((sum, item) => sum + item.quantidade, 0);
    const valorTotal = itens.reduce((sum, item) => sum + (item.quantidade * item.valor_mnt_dia * diasOperacao), 0);

    // Agrupar itens por categoria para melhor visualização na memória
    const itensPorCategoria = itens.reduce((acc, item) => {
        if (!acc[item.categoria]) { acc[item.categoria] = []; }
        acc[item.categoria].push(item);
        return acc;
    }, {} as Record<Categoria, ItemClasseII[]>);

    let detalhamentoItens = "";
    
    Object.entries(itensPorCategoria).forEach(([categoria, itensGrupo]) => {
        detalhamentoItens += `\n--- ${categoria.toUpperCase()} ---\n`;
        itensGrupo.forEach(item => {
            const valorItem = item.quantidade * item.valor_mnt_dia * diasOperacao;
            detalhamentoItens += `- ${item.quantidade} ${item.item} x ${formatCurrency(item.valor_mnt_dia)}/dia x ${diasOperacao} dias = ${formatCurrency(valorItem)}.\n`;
        });
    });
    
    // Remove a primeira quebra de linha
    detalhamentoItens = detalhamentoItens.trim();

    return `33.90.30 - Aquisição de Material de Intendência (Diversos) para ${totalItens} itens, durante ${diasOperacao} dias de ${faseFormatada}, para ${organizacao}.

Cálculo:
Fórmula: Nr Itens x Valor Mnt/Dia x Nr Dias de Operação.

${detalhamentoItens}

Valor Total: ${formatCurrency(valorTotal)}.`;
  };
  
  // NOVA FUNÇÃO: Detalhamento INDIVIDUAL por Item
  const generateItemMemoriaCalculo = (item: ItemClasseII, diasOperacao: number, organizacao: string, ug: string, faseAtividade: string): string => {
    // Se houver memória customizada, usa ela.
    if (item.memoria_customizada) {
      return item.memoria_customizada;
    }
    
    const faseFormatada = formatFasesParaTexto(faseAtividade);
    const valorItem = item.quantidade * item.valor_mnt_dia * diasOperacao;

    return `33.90.30 - Aquisição de Material de Intendência (${item.categoria}) - Item: ${item.item}
OM de Destino: ${organizacao} (UG: ${ug})
Período: ${diasOperacao} dias de ${faseFormatada}

Cálculo:
Fórmula: Nr Itens x Valor Mnt/Dia x Nr Dias de Operação.

- ${item.quantidade} ${item.item} x ${formatCurrency(item.valor_mnt_dia)}/dia x ${diasOperacao} dias = ${formatCurrency(valorItem)}.

Valor Total do Item: ${formatCurrency(valorItem)}.`;
  };

  const resetFormFields = () => {
    setEditingId(null);
    setForm({
      selectedOmId: undefined,
      organizacao: "",
      ug: "",
      dias_operacao: 0,
      itens: [],
    });
    setItemTemp({
      item: "",
      quantidade: 0,
      valor_mnt_dia: 0,
      categoria: CATEGORIAS[0], // Inicializa com a primeira categoria
    });
    setEditingItemIndex(null);
    setFasesAtividade(["Execução"]);
    setCustomFaseAtividade("");
  };

  const handleOMChange = (omData: OMData | undefined) => {
    if (omData) {
      setForm({ ...form, selectedOmId: omData.id, organizacao: omData.nome_om, ug: omData.codug_om });
    } else {
      setForm({ ...form, selectedOmId: undefined, organizacao: "", ug: "" });
    }
  };

  const handleFaseChange = (fase: string, checked: boolean) => {
    if (checked) {
      setFasesAtividade([...fasesAtividade, fase]);
    } else {
      setFasesAtividade(fasesAtividade.filter(f => f !== fase));
    }
  };

  const handleItemSelect = (itemName: string) => {
    const diretriz = diretrizes.find(d => d.item === itemName && d.categoria === selectedTab);
    if (diretriz) {
      setItemTemp(prev => ({
        ...prev,
        item: itemName,
        valor_mnt_dia: Number(diretriz.valor_mnt_dia),
        categoria: diretriz.categoria as Categoria, // Define a categoria do item
        memoria_customizada: null, // Limpa customização ao selecionar novo item
      }));
    }
  };

  const adicionarOuAtualizarItem = () => {
    if (!itemTemp.item || itemTemp.quantidade <= 0 || itemTemp.valor_mnt_dia <= 0) {
      toast.error("Preencha todos os campos do item (Item, Quantidade, Valor)");
      return;
    }

    const novoItem: ItemClasseII = { ...itemTemp };
    let novosItens = [...form.itens];
    
    // Verifica se o item já existe no formulário (exceto se estiver editando)
    const existingIndex = novosItens.findIndex(i => i.item === novoItem.item);
    
    if (editingItemIndex !== null) {
      novosItens[editingItemIndex] = novoItem;
      toast.success("Item atualizado!");
    } else if (existingIndex !== -1) {
      toast.error("Este item já foi adicionado. Edite o item existente ou remova-o primeiro.");
      return;
    } else {
      novosItens.push(novoItem);
      toast.success("Item adicionado!");
    }
    
    setForm({ ...form, itens: novosItens });
    setItemTemp({
      item: "",
      quantidade: 0,
      valor_mnt_dia: 0,
      categoria: selectedTab, // Mantém a categoria da aba atual para o próximo item
    });
    setEditingItemIndex(null);
    
    // Foca de volta no seletor de item para adicionar o próximo
    if (itemSelectRef.current) {
      itemSelectRef.current.focus();
    }
  };

  const handleEditItem = (item: ItemClasseII, index: number) => {
    setItemTemp(item);
    setEditingItemIndex(index);
    setSelectedTab(item.categoria); // Muda a aba para a categoria do item
    if (formRef.current) { formRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
  };

  const handleCancelEditItem = () => {
    setItemTemp({ item: "", quantidade: 0, valor_mnt_dia: 0, categoria: selectedTab });
    setEditingItemIndex(null);
  };

  const removerItem = (index: number) => {
    if (!confirm("Deseja realmente remover este item?")) return;
    const novosItens = form.itens.filter((_, i) => i !== index);
    setForm({ ...form, itens: novosItens });
    if (editingItemIndex === index) { handleCancelEditItem(); }
    toast.success("Item removido!");
  };

  const handleSalvarRegistros = async () => {
    if (!ptrabId) return;
    if (!form.organizacao || !form.ug) { toast.error("Selecione uma OM"); return; }
    if (form.dias_operacao <= 0) { toast.error("Dias de operação deve ser maior que zero"); return; }
    if (form.itens.length === 0) { toast.error("Adicione pelo menos um item"); return; }
    
    let fasesFinais = [...fasesAtividade];
    if (customFaseAtividade.trim()) { fasesFinais = [...fasesFinais, customFaseAtividade.trim()]; }
    const faseFinalString = fasesFinais.filter(f => f).join('; ');
    if (!faseFinalString) { toast.error("Selecione ou digite pelo menos uma Fase da Atividade."); return; }

    setLoading(true);
    
    // --- CONSOLIDAÇÃO EM UM ÚNICO REGISTRO ---
    const valorTotal = form.itens.reduce((sum, item) => sum + (item.quantidade * item.valor_mnt_dia * form.dias_operacao), 0);
    const detalhamento = generateDetalhamento(form.itens, form.dias_operacao, form.organizacao, faseFinalString);
    
    const registroParaSalvar: TablesInsert<'classe_ii_registros'> = {
      p_trab_id: ptrabId,
      organizacao: form.organizacao,
      ug: form.ug,
      dias_operacao: form.dias_operacao,
      categoria: 'CONSOLIDADO', // Usar um valor genérico para o registro consolidado
      itens_equipamentos: JSON.parse(JSON.stringify(form.itens)),
      valor_total: valorTotal,
      detalhamento: detalhamento,
      fase_atividade: faseFinalString,
      detalhamento_customizado: null, 
    };
    
    try {
      // 1. Deletar registros existentes para esta OM/UG (agora só deve haver um)
      const { error: deleteError } = await supabase
        .from("classe_ii_registros")
        .delete()
        .eq("p_trab_id", ptrabId)
        .eq("organizacao", form.organizacao)
        .eq("ug", form.ug);
      if (deleteError) { console.error("Erro ao deletar registros existentes:", deleteError); throw deleteError; }
      
      // 2. Inserir o novo registro consolidado
      const { error: insertError } = await supabase.from("classe_ii_registros").insert([registroParaSalvar]);
      if (insertError) throw insertError;
      
      toast.success("Registro de Classe II salvo com sucesso!");
      await updatePTrabStatusIfAberto(ptrabId);
      resetFormFields();
      fetchRegistros();
    } catch (error) {
      console.error("Erro ao salvar registros de Classe II:", error);
      toast.error("Erro ao salvar registros de Classe II");
    } finally {
      setLoading(false);
    }
  };

  const handleEditarRegistro = async (registro: ClasseIIRegistro) => {
    setLoading(true);
    resetFormFields();
    
    const consolidatedItems = registro.itens_equipamentos || [];
    let selectedOmIdForEdit: string | undefined = undefined;
    
    try {
      const { data: omData, error: omError } = await supabase
        .from('organizacoes_militares')
        .select('id')
        .eq('nome_om', registro.organizacao)
        .eq('codug_om', registro.ug)
        .single();
      if (omData && !omError) {
        selectedOmIdForEdit = omData.id;
      }
    } catch (error) {
      console.error("Erro ao buscar OM para edição:", error);
    }
    
    setEditingId(registro.id); 
    setForm({
      selectedOmId: selectedOmIdForEdit,
      organizacao: registro.organizacao,
      ug: registro.ug,
      dias_operacao: registro.dias_operacao,
      itens: consolidatedItems,
    });
    
    const fasesSalvas = (registro.fase_atividade || 'Execução').split(';').map(f => f.trim()).filter(f => f);
    setFasesAtividade(fasesSalvas.filter(f => FASES_PADRAO.includes(f)));
    setCustomFaseAtividade(fasesSalvas.find(f => !FASES_PADRAO.includes(f)) || "");
    
    window.scrollTo({ top: 0, behavior: 'smooth' });
    setLoading(false);
  };

  // --- Lógica de Edição de Memória Individual ---
  const handleOpenMemoriaDialog = (registro: ClasseIIRegistro, item: ItemClasseII, itemIndex: number) => {
    const memoriaOriginal = generateItemMemoriaCalculo(
      { ...item, memoria_customizada: null }, // Força a geração da memória automática
      registro.dias_operacao, 
      registro.organizacao, 
      registro.ug, 
      registro.fase_atividade || 'Execução'
    );
    
    setCurrentMemoriaItem({
      registroId: registro.id,
      itemIndex: itemIndex,
      itemNome: item.item,
      memoria: item.memoria_customizada || memoriaOriginal,
      memoriaOriginal: memoriaOriginal,
    });
    setShowMemoriaDialog(true);
  };
  
  const handleSaveMemoriaIndividual = async () => {
    if (!currentMemoriaItem) return;
    
    setLoading(true);
    
    try {
      // 1. Buscar o registro atual
      const { data: currentRegistro, error: fetchError } = await supabase
        .from("classe_ii_registros")
        .select("itens_equipamentos, organizacao, ug, dias_operacao, fase_atividade")
        .eq("id", currentMemoriaItem.registroId)
        .single();
        
      if (fetchError || !currentRegistro) throw new Error("Registro não encontrado.");
      
      const itens = currentRegistro.itens_equipamentos as ItemClasseII[];
      
      // 2. Atualizar o item específico no array
      if (currentMemoriaItem.itemIndex >= 0 && currentMemoriaItem.itemIndex < itens.length) {
        const isCustom = currentMemoriaItem.memoria.trim() !== currentMemoriaItem.memoriaOriginal.trim();
        
        itens[currentMemoriaItem.itemIndex] = {
          ...itens[currentMemoriaItem.itemIndex],
          memoria_customizada: isCustom ? currentMemoriaItem.memoria.trim() : null,
        };
      } else {
        throw new Error("Índice do item inválido.");
      }
      
      // 3. Salvar o array itens_equipamentos atualizado de volta no banco
      const { error: updateError } = await supabase
        .from("classe_ii_registros")
        .update({
          itens_equipamentos: itens,
          updated_at: new Date().toISOString(),
        })
        .eq("id", currentMemoriaItem.registroId);

      if (updateError) throw updateError;

      toast.success(`Memória de cálculo para ${currentMemoriaItem.itemNome} atualizada!`);
      setShowMemoriaDialog(false);
      setCurrentMemoriaItem(null);
      fetchRegistros();
    } catch (error) {
      console.error("Erro ao salvar memória individual:", error);
      toast.error(sanitizeError(error));
    } finally {
      setLoading(false);
    }
  };
  
  const handleRestoreMemoriaIndividual = () => {
    if (!currentMemoriaItem) return;
    setCurrentMemoriaItem(prev => prev ? { ...prev, memoria: prev.memoriaOriginal } : null);
  };
  // --- Fim Lógica de Edição de Memória Individual ---


  // Filtra as diretrizes disponíveis para a aba selecionada
  const itensDisponiveis = useMemo(() => {
    return diretrizes.filter(d => d.categoria === selectedTab);
  }, [diretrizes, selectedTab]);
  
  // Calcula o valor total do item temporário
  const valorItemTemp = itemTemp.quantidade * itemTemp.valor_mnt_dia * form.dias_operacao;
  
  // Calcula o valor total do formulário
  const valorTotalForm = form.itens.reduce((sum, item) => sum + (item.quantidade * item.valor_mnt_dia * form.dias_operacao), 0);
  
  // Agrupa os registros salvos por OM/UG para exibição na tabela (agora é apenas uma lista de registros)
  const registrosAgrupados = useMemo(() => {
    return registros;
  }, [registros]);

  return (
    <div className="min-h-screen bg-background p-4 md:p-8">
      <div className="max-w-6xl mx-auto">
        <Button
          variant="ghost"
          onClick={() => navigate(`/ptrab/form?ptrabId=${ptrabId}`)}
          className="mb-4"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Voltar
        </Button>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              Classe II - Material de Intendência
            </CardTitle>
            <CardDescription>
              Solicitação de recursos para manutenção de material de intendência.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            
            {/* 1. Dados da Organização e Dias */}
            <div className="space-y-3 border-b pb-4">
              <h3 className="text-lg font-semibold">1. Dados da Organização</h3>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="space-y-2">
                  <Label>Organização Militar (OM) *</Label>
                  <OmSelector
                    selectedOmId={form.selectedOmId}
                    onChange={handleOMChange}
                    placeholder="Selecione a OM..."
                  />
                </div>

                <div className="space-y-2">
                  <Label>UG</Label>
                  <Input value={form.ug} readOnly disabled onKeyDown={handleEnterToNextField} />
                </div>
                
                <div className="space-y-2">
                  <Label>Dias de Atividade *</Label>
                  <Input
                    type="number"
                    min="1"
                    className="[appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                    value={form.dias_operacao || ""}
                    onChange={(e) => setForm({ ...form, dias_operacao: parseInt(e.target.value) || 0 })}
                    placeholder="Ex: 7"
                    onKeyDown={handleEnterToNextField}
                  />
                </div>
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label>Fase da Atividade *</Label>
                  <Popover open={isPopoverOpen} onOpenChange={setIsPopoverOpen}>
                    <PopoverTrigger asChild>
                      <Button
                        variant="outline"
                        role="combobox"
                        type="button"
                        className="w-full justify-between"
                      >
                        {fasesAtividade.length === 0 && !customFaseAtividade.trim()
                          ? "Selecione as fases..."
                          : [...fasesAtividade, customFaseAtividade.trim()].filter(f => f).join(', ')}
                        <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-[300px] p-0" align="start">
                      <Command>
                        <CommandGroup>
                          {FASES_PADRAO.map((fase) => (
                            <CommandItem
                              key={fase}
                              value={fase}
                              onSelect={() => handleFaseChange(fase, !fasesAtividade.includes(fase))}
                              className="flex items-center justify-between cursor-pointer"
                            >
                              <span>{fase}</span>
                              <Checkbox
                                checked={fasesAtividade.includes(fase)}
                                onCheckedChange={(checked) => handleFaseChange(fase, !!checked)}
                              />
                            </CommandItem>
                          ))}
                        </CommandGroup>
                        <div className="p-2 border-t">
                          <Label className="text-xs text-muted-foreground mb-1 block">Outra Atividade (Opcional)</Label>
                          <Input
                            value={customFaseAtividade}
                            onChange={(e) => setCustomFaseAtividade(e.target.value)}
                            placeholder="Ex: Patrulhamento"
                            onKeyDown={handleEnterToNextField}
                          />
                        </div>
                      </Command>
                    </PopoverContent>
                  </Popover>
                </div>
              </div>
            </div>

            {/* 2. Adicionar Itens por Categoria (Aba) */}
            {form.organizacao && form.dias_operacao > 0 && (
              <div className="space-y-4 border-b pb-4" ref={formRef}>
                <h3 className="text-lg font-semibold">2. Adicionar Itens</h3>
                
                <Tabs value={selectedTab} onValueChange={(value) => setSelectedTab(value as Categoria)}>
                  <TabsList className="grid w-full grid-cols-3">
                    {CATEGORIAS.map(cat => (
                      <TabsTrigger key={cat} value={cat}>{cat}</TabsTrigger>
                    ))}
                  </TabsList>
                  
                  {CATEGORIAS.map(cat => (
                    <TabsContent key={cat} value={cat} className="mt-4">
                      <div className="space-y-4 p-4 bg-muted/50 rounded-lg">
                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
                          <div className="space-y-2 col-span-2">
                            <Label>Item *</Label>
                            <Select 
                              value={itemTemp.item}
                              onValueChange={handleItemSelect}
                            >
                              <SelectTrigger ref={itemSelectRef}>
                                <SelectValue placeholder="Selecione o item..." />
                              </SelectTrigger>
                              <SelectContent>
                                {itensDisponiveis.map(d => (
                                  <SelectItem key={d.item} value={d.item}>
                                    {d.item} ({formatCurrency(Number(d.valor_mnt_dia))}/dia)
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                          </div>
                          
                          <div className="space-y-2">
                            <Label>Quantidade *</Label>
                            <Input
                              type="number"
                              min="1"
                              className="[appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                              value={itemTemp.quantidade === 0 ? "" : itemTemp.quantidade.toString()}
                              onChange={(e) => setItemTemp({ ...itemTemp, quantidade: parseInt(e.target.value) || 0 })}
                              placeholder="Ex: 10"
                              onKeyDown={handleEnterToNextField}
                            />
                          </div>
                          
                          <div className="space-y-2">
                            <Button 
                              type="button" 
                              onClick={adicionarOuAtualizarItem} 
                              className="w-full" 
                              disabled={!itemTemp.item || itemTemp.quantidade <= 0}
                            >
                              {editingItemIndex !== null ? "Atualizar Item" : "Adicionar Item"}
                            </Button>
                          </div>
                        </div>
                        
                        {itemTemp.item && (
                          <div className="flex justify-between items-center text-sm p-2 bg-background rounded-md border">
                            <span className="text-muted-foreground">Valor Mnt/Dia: {formatCurrency(itemTemp.valor_mnt_dia)}</span>
                            <span className="font-bold">Valor Calculado: {formatCurrency(valorItemTemp)}</span>
                          </div>
                        )}
                        
                        {editingItemIndex !== null && (
                          <Button
                            type="button"
                            variant="outline"
                            onClick={handleCancelEditItem}
                            className="mt-2"
                          >
                            <XCircle className="h-4 w-4 mr-2" />
                            Cancelar Edição do Item
                          </Button>
                        )}
                      </div>
                    </TabsContent>
                  ))}
                </Tabs>
              </div>
            )}

            {/* 3. Itens Adicionados e Consolidação */}
            {form.itens.length > 0 && (
              <div className="space-y-4 border-b pb-4">
                <h3 className="text-lg font-semibold">3. Itens Adicionados ({form.itens.length})</h3>
                
                <div className="space-y-2">
                  {form.itens.map((item, index) => (
                    <Card key={index} className="p-3">
                      <div className="flex items-center justify-between">
                        <div className="flex-1">
                          <p className="font-medium">{item.item} <Badge variant="secondary" className="ml-2 text-xs">{item.categoria}</Badge></p>
                          <p className="text-sm text-muted-foreground">
                            {item.quantidade} unidade(s) • {formatCurrency(item.valor_mnt_dia)}/dia • Total: {formatCurrency(item.quantidade * item.valor_mnt_dia * form.dias_operacao)}
                          </p>
                        </div>
                        <div className="flex gap-1">
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => handleEditItem(item, index)}
                          >
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => removerItem(index)}
                            className="text-destructive hover:bg-destructive/10"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                    </Card>
                  ))}
                </div>
                
                <div className="flex justify-between items-center p-3 bg-primary/10 rounded-lg border border-primary/20">
                  <span className="font-bold text-base text-primary">VALOR TOTAL DA OM</span>
                  <span className="font-extrabold text-xl text-primary">
                    {formatCurrency(valorTotalForm)}
                  </span>
                </div>
                
                <div className="flex gap-3 pt-4 justify-end">
                  <Button
                    variant="outline"
                    type="button"
                    onClick={resetFormFields}
                  >
                    <XCircle className="h-4 w-4 mr-2" />
                    Limpar Formulário
                  </Button>
                  <Button 
                    type="button" 
                    onClick={handleSalvarRegistros} 
                    disabled={loading || !form.organizacao || form.itens.length === 0}
                  >
                    {loading ? "Aguarde..." : (editingId ? "Atualizar Registros" : "Salvar Registros")}
                  </Button>
                </div>
              </div>
            )}

            {/* 4. Registros Salvos (OMs Cadastradas) - SUMMARY SECTION */}
            {registrosAgrupados.length > 0 && (
              <div className="space-y-4 mt-6">
                <h2 className="text-xl font-bold flex items-center gap-2">
                  <Sparkles className="h-5 w-5 text-accent" />
                  OMs Cadastradas
                </h2>
                
                {registrosAgrupados.map((registro) => {
                  const om = registro.organizacao;
                  const ug = registro.ug;
                  const totalOM = registro.valor_total;
                  const fases = formatFasesParaTexto(registro.fase_atividade);
                  
                  return (
                    <Card key={registro.id} className="p-4 bg-muted/30">
                      <div className="flex items-center justify-between mb-3 border-b pb-2">
                        <div className="flex items-center gap-2">
                          <h4 className="text-lg font-semibold text-foreground">{om} (UG: {ug})</h4>
                          <Badge variant="secondary" className="ml-2 text-xs">Consolidado</Badge>
                        </div>
                        <div className="flex gap-1">
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-8 w-8"
                            onClick={() => handleEditarRegistro(registro)}
                          >
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => {
                              if (confirm(`Deseja realmente deletar o registro de Classe II para ${om}?`)) {
                                // Deletar o único registro desta OM/UG
                                supabase.from("classe_ii_registros")
                                  .delete()
                                  .eq("id", registro.id)
                                  .then(() => {
                                    toast.success("Registro excluído!");
                                    fetchRegistros();
                                  })
                                  .catch(err => {
                                    toast.error(sanitizeError(err));
                                  });
                              }
                            }}
                            className="h-8 w-8 text-destructive hover:bg-destructive/10"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                      
                      <div className="space-y-2">
                        <p className="text-sm text-muted-foreground">Dias: {registro.dias_operacao} | Fases: {fases}</p>
                        
                        {/* Detalhes por Categoria */}
                        <div className="space-y-1 pt-2">
                          {/* Exibir resumo dos itens por categoria */}
                          {Object.entries(registro.itens_equipamentos.reduce((acc, item) => {
                            acc[item.categoria] = (acc[item.categoria] || 0) + item.quantidade;
                            return acc;
                          }, {} as Record<Categoria, number>)).map(([categoria, quantidade]) => (
                            <div key={categoria} className="flex justify-between text-sm border-b border-dashed pb-1">
                              <span className="font-medium text-primary">{categoria} ({quantidade} itens)</span>
                              <span className="font-semibold">{formatCurrency(registro.itens_equipamentos.filter(i => i.categoria === categoria).reduce((sum, i) => sum + (i.quantidade * i.valor_mnt_dia * registro.dias_operacao), 0))}</span>
                            </div>
                          ))}
                        </div>
                        
                        <div className="flex justify-between items-center pt-2">
                          <span className="font-bold text-base">TOTAL OM</span>
                          <span className="font-extrabold text-xl text-primary">{formatCurrency(totalOM)}</span>
                        </div>
                      </div>
                    </Card>
                  );
                })}
              </div>
            )}

            {/* 5. Memórias de Cálculos Detalhadas - AJUSTADO PARA ITERAR SOBRE ITENS */}
            {registros.length > 0 && (
              <div className="space-y-4 mt-8">
                <h2 className="text-xl font-bold flex items-center gap-2">
                  <ClipboardList className="h-5 w-5 text-primary" />
                  Memórias de Cálculos Detalhadas
                </h2>
                
                {registros.map(registro => {
                  return (
                    <div key={`memoria-view-${registro.id}`} className="space-y-4 border p-4 rounded-lg bg-muted/30">
                      <div className="flex justify-between items-center">
                        <h4 className="text-lg font-semibold text-foreground">
                          OM: {registro.organizacao} ({registro.ug})
                        </h4>
                      </div>
                      
                      <div className="space-y-3">
                        {registro.itens_equipamentos.map((item, itemIndex) => {
                          const memoria = generateItemMemoriaCalculo(
                            item, 
                            registro.dias_operacao, 
                            registro.organizacao, 
                            registro.ug, 
                            registro.fase_atividade || 'Execução'
                          );
                          
                          const isCustom = !!item.memoria_customizada;
                          
                          return (
                            <Card key={itemIndex} className="p-3 bg-background">
                              <div className="flex justify-between items-start mb-2">
                                <h6 className="font-bold text-sm">
                                  {item.item} ({item.quantidade} un.) - {item.categoria}
                                </h6>
                                <div className="flex items-center gap-2">
                                  {isCustom && (
                                    <Badge variant="outline" className="text-xs text-destructive">
                                      Customizada
                                    </Badge>
                                  )}
                                  <Button
                                    size="sm"
                                    variant="outline"
                                    className="h-7 gap-1"
                                    onClick={() => handleOpenMemoriaDialog(registro, item, itemIndex)}
                                  >
                                    <Pencil className="h-3 w-3" />
                                    Editar
                                  </Button>
                                </div>
                              </div>
                              <pre className="font-mono text-xs whitespace-pre-wrap text-foreground">
                                {memoria}
                              </pre>
                            </Card>
                          );
                        })}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </CardContent>
        </Card>
      </div>
      
      {/* Diálogo de Edição de Memória Individual */}
      <Dialog open={showMemoriaDialog} onOpenChange={setShowMemoriaDialog}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>Editar Memória de Cálculo</DialogTitle>
            <p className="text-sm text-muted-foreground">
              Item: <span className="font-semibold">{currentMemoriaItem?.itemNome}</span>
            </p>
          </DialogHeader>
          <div className="py-4 space-y-3">
            <Label htmlFor="memoria-edit">Memória de Cálculo (Texto Livre)</Label>
            <Textarea
              id="memoria-edit"
              value={currentMemoriaItem?.memoria || ''}
              onChange={(e) => setCurrentMemoriaItem(prev => prev ? { ...prev, memoria: e.target.value } : null)}
              rows={15}
              className="font-mono text-xs"
            />
            <Button 
              type="button" 
              variant="ghost" 
              size="sm" 
              onClick={handleRestoreMemoriaIndividual}
              disabled={currentMemoriaItem?.memoria === currentMemoriaItem?.memoriaOriginal}
            >
              Restaurar Memória Automática
            </Button>
          </div>
          <DialogFooter>
            <Button onClick={handleSaveMemoriaIndividual} disabled={loading}>
              {loading ? "Salvando..." : "Salvar Customização"}
            </Button>
            <Button variant="outline" onClick={() => setShowMemoriaDialog(false)}>
              Cancelar
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}